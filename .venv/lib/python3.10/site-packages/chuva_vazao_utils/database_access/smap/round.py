from functools import lru_cache
from typing import List

from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.database_access.query_builder import QueryBuilder
from chuva_vazao_utils.database_access.table_base import metaclass_resolver, TableBase
from chuva_vazao_utils.entities.exception import EntityNotFound
from chuva_vazao_utils.database_access.rain.rain_model import RainModelDatabaseApi
from chuva_vazao_utils.database_access.operative_week import SemanaOperativaSqlApi
from chuva_vazao_utils.entities.rain.rain_model import ForecastRainModel
from chuva_vazao_utils.entities.smap.round import SmapRound, SmapRoundApi


class SmapRoundSqlApi(metaclass_resolver(SmapRoundApi, TableBase)):
    _query_builder = QueryBuilder('rodada_smap')
    _database = RiverDatabase

    @classmethod
    def select(cls, condition: dict) -> List[SmapRound]:
        columns = [
            'id_rodada_smap',
            'id_smap_config',
            'id_modelo_mapa',
            'id_semana_operativa',
            'flag_acomph',
            'flag_manual',
            'rodada_smap.cpu_date',
        ]
        bd_entities = super().select(columns, where=condition)

        smap_rounds = []
        for bd_entity in bd_entities:
            try:
                if bd_entity['id_modelo_mapa'] is None:
                    raise EntityNotFound('id_modelo_mapa is null')

                model = RainModelDatabaseApi.fetch_by_id(bd_entity['id_modelo_mapa'])
            except EntityNotFound:
                # Tratamento de id_modelo_mapa = null na base (rodada customizada)
                model = ForecastRainModel(-1, 'CUSTOM', 'CUSTOM', 'CUSTOM', 'CUSTOM')

            op_week = SemanaOperativaSqlApi.fetch_by_id(bd_entity['id_semana_operativa'])

            smap_round = SmapRound(
                bd_entity['id_smap_config'],
                model,
                op_week,
                bool(bd_entity['flag_acomph']),
                bool(bd_entity['flag_manual']),
                bd_entity['id_rodada_smap'],
                bd_entity['cpu_date'],
            )
            smap_rounds.append(smap_round)
        return smap_rounds

    @classmethod
    @lru_cache
    def fetch_round_by_id(cls, id: int) -> SmapRound:
        condition = {'id_rodada_smap': id}
        smap_rounds = cls.select(condition)

        if not smap_rounds:
            raise EntityNotFound(id)
        return smap_rounds[0]

    @classmethod
    def last_round_id(cls) -> int:
        columns = ['max(id_rodada_smap) as last_round_id']
        last_round = cls.select(columns, where={})
        return last_round[0]['last_round_id']

    @classmethod
    def persist_round(cls, round: SmapRound) -> int:
        id_semana_operativa = SemanaOperativaSqlApi.fetch_id_given_semana_operativa(round.oper_week)

        db_data = {
            'id_smap_config': round.config_id,
            'id_modelo_mapa': round.model._id,
            'id_semana_operativa': id_semana_operativa,
            'flag_acomph': round.flag_acomph,
            'flag_manual': round.flag_manual,
            'cpu_date': round.cpu_date,
        }
        round_id = cls.insert(db_data)
        round.id = round_id
        return round_id

    @classmethod
    def delete_by_id(cls, id: int) -> None:
        condition = {'id_rodada_smap': id}
        cls.delete(where=condition)
