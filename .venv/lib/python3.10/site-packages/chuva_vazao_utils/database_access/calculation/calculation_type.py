from functools import lru_cache
from typing import List

from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.database_access.query_builder import QueryBuilder
from chuva_vazao_utils.database_access.table_base import metaclass_resolver, TableBase
from chuva_vazao_utils.entities.exception import EntityNotFound
from chuva_vazao_utils.entities.calculation.calculation_type import CalculationType, CalculationTypeApi, CalculationTypeMenu


class CalculationTypeDatabaseApi(metaclass_resolver(CalculationTypeApi, TableBase)):
    _query_builder = QueryBuilder('calculation_type')
    _database = RiverDatabase

    @classmethod
    @lru_cache(maxsize=4)
    def fetch_all(cls) -> List[CalculationType]:
        columns = ['id_calculation_type', 'descricao']
        bd_entities = cls.select(columns, where={})
        return [CalculationType(entity['id_calculation_type'], entity['descricao']) for entity in bd_entities]

    @classmethod
    def fetch_by_id(cls, id: int) -> CalculationType:
        calculation_types = cls.fetch_all()
        try:
            return next(calc_type for calc_type in calculation_types if calc_type.id == id)
        except StopIteration as e:
            raise EntityNotFound(id) from e

    @classmethod
    def fetch_by_name(cls, name: str) -> CalculationType:
        calculation_types = cls.fetch_all()
        try:
            return next(calc_type for calc_type in calculation_types if calc_type.name == name)
        except StopIteration as e:
            raise EntityNotFound(name) from e

    @classmethod
    def fetch_calculation_type(cls, calc_type: CalculationTypeMenu) -> CalculationType:
        return cls.fetch_by_id(calc_type.value)
