from typing import List, Union
from datetime import date, datetime

from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.entities.inflow.inflow import Inflow, InflowApi
from chuva_vazao_utils.database_access.table_base import TableBase, metaclass_resolver
from chuva_vazao_utils.entities.inflow.inflow_source import InflowSource
from chuva_vazao_utils.entities.inflow.inflow_type import InflowType
from chuva_vazao_utils.entities.inflow.origin_type import OriginType
from chuva_vazao_utils.entities.power_plant.power_plant import PowerPlant
from chuva_vazao_utils.database_access.query_builder import QueryBuilder
from chuva_vazao_utils.database_access.inflows.inflow_source import InflowSourceDatabaseApi
from chuva_vazao_utils.database_access.inflows.inflow_type import InflowTypeDatabaseApi
from chuva_vazao_utils.database_access.inflows.origin_type import OriginTypeDatabaseApi
from chuva_vazao_utils.database_access.power_plant.power_plant import PowerPlantDatabaseApi
from chuva_vazao_utils.utils.dateutils import get_now


class InflowDatabaseApi(metaclass_resolver(InflowApi, TableBase)):
    _query_builder = QueryBuilder('inflow')
    _database = RiverDatabase

    @classmethod
    def from_dict(cls, inflow: dict) -> Inflow:
        return Inflow(
            time=inflow.get('inflow_date'),
            value=float(inflow.get('value')),
            power_plant=PowerPlantDatabaseApi.fetch_by_id(inflow.get('id_power_plant')),
            inflow_type=InflowTypeDatabaseApi.fetch_by_id(inflow.get('id_type_inflow')),
            source=InflowSourceDatabaseApi.fetch_by_id(inflow.get('id_inflow_source')),
            origin=OriginTypeDatabaseApi.fetch_by_id(inflow.get('id_origin_type')),
            id=inflow.get('id_inflow'),
            round_id=inflow.get('id_rodada_smap'),
        )

    @classmethod
    def parse_from_list(cls, inflows: List[dict]) -> List[Inflow]:
        if isinstance(inflows[0], Inflow):
            return inflows
        elif isinstance(inflows[0], dict):
            return [cls.from_dict(inflow) for inflow in inflows]
        raise TypeError('Inflows must be a list of Inflow or dict')

    @classmethod
    def select(cls, where: dict, groupby: Union[str, List[str]] = None, limit: int = None) -> List[Inflow]:
        columns = [
            'inflow_date', 'value', 'id_power_plant', 'id_type_inflow', 'id_inflow_source', 'id_origin_type', 'id_inflow', 'id_rodada_smap'
        ]
        bd_entities = super().select(columns, where, groupby, limit)
        return [cls.from_dict(bd_entity) for bd_entity in bd_entities]

    @classmethod
    def fetch_between_dates(
        cls,
        begin_date: datetime,
        end_date: datetime,
        power_plants: Union[PowerPlant, List[PowerPlant]] = -1,
        inflow_type: Union[InflowType, None] = -1,
        inflow_source: Union[InflowSource, None] = -1,
        origin_type: Union[OriginType, None] = -1,
        round_id: Union[int, None] = -1
    ) -> List[Inflow]:
        condition = {
            'end_date': None,
            'inflow_date': [begin_date, end_date],
        }

        if power_plants != -1:
            if isinstance(power_plants, PowerPlant):
                power_plants = [power_plants]

            condition['id_power_plant'] = [pp.id for pp in power_plants] if power_plants else None

        if inflow_type != -1:
            condition['id_type_inflow'] = inflow_type.id if inflow_type else None

        if inflow_source != -1:
            condition['id_inflow_source'] = inflow_source.id if inflow_source else None

        if origin_type != -1:
            condition['id_origin_type'] = origin_type.id if origin_type else None

        if round_id != -1:
            condition['id_rodada_smap'] = round_id

        return cls.select(condition)

    @classmethod
    def persist_inflows(cls, inflows: Union[Inflow, List[Inflow]]):
        if isinstance(inflows, Inflow):
            inflows = [inflows]

        db_data = [
            {
                'id_inflow_source': inflow.source.id,
                'id_origin_type': inflow.origin.id,
                'id_type_inflow': inflow.inflow_type.id,
                'begin_date': get_now(),
                'id_power_plant': inflow.power_plant.id,
                'inflow_date': inflow.time,
                'value': inflow.value,
                'id_rodada_smap': inflow.round_id,
            }
            for inflow in inflows
        ]
        cls.insert(db_data)

    @classmethod
    def end_inflows_validity(cls, inflows: Union[Inflow, List[Inflow]], end_date: datetime = get_now()):
        if isinstance(inflows, Inflow):
            inflows = [inflows]

        values = [{'end_date': end_date}]
        conditions = [{'id_inflow': [i.id for i in inflows]}]
        cls.update(values, where=conditions)

    @classmethod
    def check_inflow_origin_was_loaded_on_date(cls, inflow_origin: OriginType, date: date) -> bool:
        columns = ['id_inflow']
        condition = {
            'end_date': None,
            'id_origin_type': inflow_origin.id,
            'DATE(begin_date)': date
        }
        inflows = super().select(columns, where=condition, limit=1)
        return bool(inflows)
