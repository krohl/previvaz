from typing import List
from functools import lru_cache

from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.entities.exception import EntityNotFound
from chuva_vazao_utils.database_access.table_base import TableBase, metaclass_resolver
from chuva_vazao_utils.database_access.river.river import RiverDatabaseApi
from chuva_vazao_utils.database_access.query_builder import QueryBuilder
from chuva_vazao_utils.database_access.power_plant.ree import ReservatorioEquivalenteDatabaseApi
from chuva_vazao_utils.entities.power_plant.power_plant import PowerPlant, PowerPlantApi
from chuva_vazao_utils.database_access.subsystem.subsystem import SubsystemDatabaseApi


class PowerPlantDatabaseApi(metaclass_resolver(PowerPlantApi, TableBase)):
    _query_builder = QueryBuilder('power_plant')
    _database = RiverDatabase

    COD_99999999 = '99999999'

    @classmethod
    def from_dict(cls, pp: dict) -> PowerPlant:
        return PowerPlant(
            pp.get('name_power_plant'),
            pp.get('full_name_power_plant'),
            RiverDatabaseApi.fetch_by_id(pp.get('id_river')),
            pp.get('cod_power_plant'),
            pp.get('posto_rdh'),
            pp.get('codigo_ana'),
            pp.get('latitude'),
            pp.get('longitude'),
            pp.get('smap_flag'),
            pp.get('fluviometrico_flag'),
            ReservatorioEquivalenteDatabaseApi.fetch_by_id(pp.get('id_reservatorio_equivalente')),
            SubsystemDatabaseApi.fetch_by_id(pp.get('id_subsistema')),
            pp.get('begin_date'),
            pp.get('end_date'),
            pp.get('id_power_plant'),
        )

    @classmethod
    def parse_from_list(cls, power_plants: List[dict]) -> List[PowerPlant]:
        if isinstance(power_plants[0], PowerPlant):
            return power_plants
        elif isinstance(power_plants[0], dict):
            return [cls.from_dict(pp) for pp in power_plants]
        raise TypeError('Inflows must be a list of PowerPlant or dict')

    @classmethod
    def select(cls, conditions: dict, only_valid: bool = True) -> List[PowerPlant]:
        columns = [
            'name_power_plant', 'full_name_power_plant', 'id_river', 'cod_power_plant', 'posto_rdh', 'codigo_ana', 'latitude', 'longitude',
            'smap_flag', 'fluviometrico_flag', 'id_reservatorio_equivalente', 'id_subsistema', 'begin_date', 'end_date', 'id_power_plant'
        ]
        if only_valid:
            conditions['end_date'] = None

        bd_entities = super().select(columns, where=conditions)
        return [cls.from_dict(pp) for pp in bd_entities]

    @classmethod
    @lru_cache(maxsize=32)
    def fetch_all(cls) -> List[PowerPlant]:
        return cls.select({})

    @classmethod
    @lru_cache(maxsize=32)
    def fetch_all_smap_power_plants(cls) -> List[PowerPlant]:
        # No refatoramento do pós-processamento, devemos reavaliar a base de dados.
        # Essa query, hoje 19/01/2023, retorna 195 usinas.
        # O pós-processamento insere na tabela inflow, vazões de 181 usinas.
        # Ao fazer uma função como essa, pensei que teríamos a lista de usinas a serem calculadas pelo pós-processamento.
        conditions = {
            'smap_flag': 1
        }
        return cls.select(conditions)

    @classmethod
    @lru_cache(maxsize=32)
    def fetch_fluviometric_power_plants(cls) -> List[PowerPlant]:
        conditions = {
            'fluviometrico_flag': 1
        }
        return cls.select(conditions)

    @classmethod
    @lru_cache(maxsize=32)
    def fetch_smap_deck_power_plants(cls) -> List[PowerPlant]:
        smap_power_plants = cls.fetch_all_smap_power_plants()
        return [
            pp for pp in smap_power_plants
            if pp.codigo_ana is not None and pp.cod != cls.COD_99999999
        ]

    @classmethod
    def fetch_by_id(cls, id: int) -> PowerPlant:
        power_plants = cls.fetch_all()
        try:
            return next(pp for pp in power_plants if pp.id == id)
        except StopIteration as e:
            raise EntityNotFound(id) from e

    @classmethod
    def fetch_by_full_name(cls, full_name: str) -> PowerPlant:
        power_plants = cls.fetch_all()
        try:
            return next(pp for pp in power_plants if pp.full_name == full_name)
        except StopIteration as e:
            raise EntityNotFound(full_name) from e

    @classmethod
    def fetch_by_posto_rdh(cls, posto_rdh: str) -> PowerPlant:
        power_plants = cls.fetch_all()
        try:
            return next(pp for pp in power_plants if pp.posto_rdh == posto_rdh)
        except StopIteration as e:
            raise EntityNotFound(posto_rdh) from e
