from typing import List
from functools import lru_cache

from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.entities.exception import EntityNotFound
from chuva_vazao_utils.entities.river.river import River, RiverApi
from chuva_vazao_utils.database_access.table_base import TableBase, metaclass_resolver
from chuva_vazao_utils.database_access.query_builder import QueryBuilder


class RiverDatabaseApi(metaclass_resolver(RiverApi, TableBase)):
    _query_builder = QueryBuilder('river')
    _database = RiverDatabase

    @classmethod
    def from_dict(cls, river: dict) -> River:
        return River(
            name=river.get('name_river'),
            order=river.get('order'),
            configs=river.get('configs'),
            id=river.get('id_river')
        )

    @classmethod
    def parse_from_list(cls, rivers: List[dict]) -> List[River]:
        if isinstance(rivers[0], River):
            return rivers
        elif isinstance(rivers[0], dict):
            return [cls.from_dict(r) for r in rivers]
        raise TypeError('Inflows must be a list of PowerPlant or dict')

    @classmethod
    def select(cls, conditions: dict, only_valid: bool = True) -> List[River]:
        columns = [
            'name_river', '`order`', 'configs', 'id_river'
        ]
        if only_valid:
            conditions['end_date'] = None

        bd_entities = super().select(columns, where=conditions)
        return [cls.from_dict(pp) for pp in bd_entities]

    @classmethod
    @lru_cache(maxsize=32)
    def fetch_all(cls) -> List[River]:
        return cls.select({})

    @classmethod
    def fetch_by_id(cls, id: int) -> River:
        rivers = cls.fetch_all()
        try:
            return next(pp for pp in rivers if pp.id == id)
        except StopIteration as e:
            raise EntityNotFound(id) from e
