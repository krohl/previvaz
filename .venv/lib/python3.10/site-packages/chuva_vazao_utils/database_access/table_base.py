from __future__ import annotations

from typing import List, Tuple, Union

from chuva_vazao_utils.connection import DatabaseSelector, DatabaseMenu, RiverDatabase
from chuva_vazao_utils.utils.classproperty import classproperty, classproperty_support
from chuva_vazao_utils.database_access.query_builder import QueryBuilder


def metaclass_resolver(*classes):
    """Função para permitir herança múltipla com TableBase. Deve ser usada na definição da classe filha:
    Ex.: class NovaClasse(metaclass_resolver(ClasseMae, TableBase))

    Sem isso, há conflito de metadados na NovaClasse
    """
    metaclass = tuple(set(type(cls) for cls in classes))
    metaclass = metaclass[0] if len(metaclass) == 1 \
        else type("_".join(mcls.__name__ for mcls in metaclass), metaclass, {})
    return metaclass("_".join(cls.__name__ for cls in classes), classes, {})


@classproperty_support
class TableBase:
    _query_builder = QueryBuilder('')
    _database = RiverDatabase  # Default para compatibilidade com versões anteriores

    @classproperty
    def query_builder(self) -> QueryBuilder:
        return self._query_builder

    @classmethod
    def from_tablename(cls, class_name: str, tablename: str, db: DatabaseMenu = DatabaseMenu.RIVER_DB) -> TableBase:
        new_class = type(class_name, (TableBase,), {})
        new_class._query_builder = QueryBuilder(tablename)
        new_class._database = DatabaseSelector.get_database(db)
        return new_class

    @classmethod
    def join(cls, table_name: str, on: Union[Tuple[str], List[Tuple[str]]] = None, join_type='') -> TableBase:
        cls.query_builder.join_table(table_name, on, join_type)
        return cls

    @classmethod
    def select(cls, columns: List[str], where: dict, groupby: Union[str, List[str]] = None, limit: int = None):
        if isinstance(columns, list):
            columns = ', '.join(columns)

        stm, data = cls.query_builder.create_select(columns, where, groupby, limit)
        cursor = cls._database.execute(stm, data)
        return cursor.fetchall()

    @classmethod
    def insert(cls, values: Union[dict, List[dict]], auto_commit: bool = True):
        if isinstance(values, list) and len(values) > 0:
            first_param = values[0]

            stm, _ = cls.query_builder.create_insert(**first_param)
            data = [tuple(v.values()) for v in values]
            cls._database.executemany(stm, data, auto_commit)

        if isinstance(values, dict):
            stm, data = cls.query_builder.create_insert(**values)
            cursor = cls._database.execute(stm, data, auto_commit)
            return cursor.lastrowid

    @classmethod
    def update(cls, values: List[dict], where: List[dict], auto_commit: bool = True):
        if values and len(values) == len(where):
            all_data = []
            statements = []

            for value, condition in zip(values, where):
                stm, data = cls.query_builder.create_update(value, condition)
                statements.append(stm)
                all_data.append(data)

            stm_equals = all(x in statements[0] for x in statements)

            if stm_equals:
                cls._database.executemany(statements[0], all_data, auto_commit)
            else:
                for stm, data in zip(statements, all_data):
                    cls._database.execute(stm, data, auto_commit)

    @classmethod
    def delete(cls, where: dict, auto_commit: bool = True):
        if where:
            stm, data = cls.query_builder.create_delete(where)
            cls._database.execute(stm, data, auto_commit)

    @classmethod
    def commit(cls):
        connection = cls._database.get_connection()
        connection.commit()
