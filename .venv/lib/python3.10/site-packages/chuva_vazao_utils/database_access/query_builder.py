from typing import List, Tuple, Union

from chuva_vazao_utils.exceptions import QueryError
from chuva_vazao_utils.database_access.query_formatter import QueryFormatter


class QueryBuilder:

    def __init__(self, table_name) -> None:
        self._table_name = table_name
        self._select_stm = "SELECT {columns} FROM {table_name} {join} WHERE {conditions}"
        self._insert_stm = "INSERT INTO {table_name} ({columns}) VALUES ({values})"
        self._update_stm = "UPDATE {table_name} SET {values} WHERE {conditions}"
        self._delete_stm = "DELETE FROM {table_name} WHERE {conditions}"
        self._join_stm = ''

    def join_table(self, table_name: str, on: Union[Tuple[str], List[Tuple[str]]] = None, join_type: str = ''):
        if isinstance(on, tuple):
            on = [on]

        self._join_stm += ''.join(
            f' {join_type} JOIN {table_name} ON {join_on} = {join_on_main} ' for join_on, join_on_main in on
        )

    def create_select(self, columns: str = '*', conditions: dict = {}, groupby: List[str] = None, limit: int = None):
        values_select = []
        if conditions == {}:
            condition_stm = ''
            self._select_stm = self._select_stm.replace('WHERE', '')
        else:
            condition_stms = []

            formatter = QueryFormatter()
            for column, condition in conditions.items():
                condition_str = formatter.format(column, condition, values_select)
                if condition_str is None:
                    self._query_error('SELECT', column, condition)

                condition_stms.append(condition_str)

            condition_stm = ' and '.join(condition_stms)

        stm = self._select_stm.format(
            table_name=self._table_name,
            join=self._join_stm,
            columns=columns,
            conditions=condition_stm,
        )
        if groupby is not None:
            stm += 'GROUP BY ' + ', '.join(groupby)

        if limit is not None:
            stm += f'LIMIT {limit}'

        return stm, tuple(values_select)

    def create_insert(self, **kwargs):
        columns = ', '.join(kwargs.keys())
        values = ', '.join(['%s' for _ in kwargs.values()])
        values_insert = kwargs.values()

        stm = self._insert_stm.format(
            table_name=self._table_name,
            columns=columns,
            values=values
        )
        return stm, tuple(values_insert)

    def create_update(self, value: dict, condition: dict):
        values_columns = value.keys()
        condition_columns = []

        values_update = list(value.values())

        formatter = QueryFormatter()
        for column, condition_value in condition.items():
            condition_str = formatter.format(column, condition_value, values_update)
            condition_columns.append(condition_str)

        stm_values = ', '.join(map(lambda x: f'{x} = %s', values_columns))
        stm_condition = ' and '.join(condition_columns)

        stm = self._update_stm.format(
            table_name=self._table_name,
            values=stm_values,
            conditions=stm_condition
        )
        return stm, tuple(values_update)

    def create_delete(self, condition: dict):
        values_delete = []
        condition_stms = []

        formatter = QueryFormatter()
        for column, condition_value in condition.items():
            condition_str = formatter.format(column, condition_value, values_delete)
            if condition_str is None:
                self._query_error('DELETE', column, condition_value)

            condition_stms.append(condition_str)

        condition_stm = ' and '.join(condition_stms)

        stm = self._delete_stm.format(
            table_name=self._table_name,
            conditions=condition_stm,
        )
        return stm, tuple(values_delete)

    def _query_error(self, stm_type, column, value):
        msg = f'Error formating {stm_type} query for table: {self._table_name}, column: {column}, with condition: {value}'
        raise QueryError(msg)
