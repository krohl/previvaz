import json
from datetime import date
from typing import List, Union

from chuva_vazao_utils.aws.s3.remvies.round import RemviesRoundS3Api
from chuva_vazao_utils.connection import RiverDatabase
from chuva_vazao_utils.database_access.query_builder import QueryBuilder
from chuva_vazao_utils.database_access.table_base import metaclass_resolver, TableBase
from chuva_vazao_utils.entities.exception import EntityNotFound, NoRemviesRoundWithOutputForDate
from chuva_vazao_utils.entities.remvies.round import RemviesRound, RemviesRoundApi
from chuva_vazao_utils.utils.dateutils import get_today


class RemviesRoundSqlApi(metaclass_resolver(RemviesRoundApi, TableBase)):
    _query_builder = QueryBuilder('smap_input')
    _database = RiverDatabase

    @classmethod
    def fetch_round_by_id(cls, id: int) -> RemviesRound:
        condition = {'id_smap_input': id}
        return cls._fetch_rounds(condition, False)[0]

    @classmethod
    def fetch_round_before(cls, ref_round: RemviesRound) -> Union[RemviesRound, None]:
        """Retorna a rodada Remvies anterior à de ref_round_id

        Args:
            ref_round_id (int): id da rodada remvies de referência

        Returns:
            Union[RemviesRound, None]: caso não haja rodada anterior, returna None
        """
        condition = {'base_date': ref_round.base_date}
        rounds = cls._fetch_rounds(condition, False)
        return next((round for round in rounds if round.id < ref_round.id), None)

    @classmethod
    def last_round_given_base_date(cls, base_date: date, only_rounds_today=True, only_rounds_with_output=False) -> RemviesRound:
        """Busca última rodada de remoção de viés, dada base_date

        Args:
            base_date (date): base_date da rodada de remoção de viés
            only_rounds_today (bool, optional): Se True, só busca rodadas com cpu_date na data de hoje. Defaults to True.
            only_rounds_with_output (bool, optional): Se True, busca a última rodada que tenha sido de fato executada. Defaults to False.

        Raises:
            NoRemviesRoundWithOutputForDate: Lançada caso não sejam encontradas rodadas de remoção de viés com output na data.

        Returns:
            RemviesRound: Entidade que representa a rodada da remoção de viés solicitada
        """
        condition = {'base_date': base_date}
        rounds = cls._fetch_rounds(condition, only_rounds_today)

        if not only_rounds_with_output:
            return max(rounds)

        ordered_rounds = sorted(rounds, reverse=True)
        for round in ordered_rounds:
            if round.output_base_folder.exists():
                return round

        raise NoRemviesRoundWithOutputForDate(base_date)

    @classmethod
    def _fetch_rounds(cls, condition: dict, only_rounds_today=True) -> List[RemviesRound]:
        columns = ['id_smap_input', 'input', 'id_remvies_config', 'base_date', 'cpu_date']
        if(only_rounds_today):
            condition['cpu_date'] = [get_today(), None]

        remvies_rounds = cls.select(columns, where=condition)

        if not remvies_rounds:
            raise EntityNotFound(condition)

        rounds = [
            RemviesRound(remvies_round['id_smap_input'], json.loads(remvies_round['input']), remvies_round['id_remvies_config'],
                         remvies_round['base_date'], remvies_round['cpu_date'], RemviesRoundS3Api)
            for remvies_round in remvies_rounds
        ]
        rounds = sorted(rounds, reverse=True)
        return rounds

    @classmethod
    def persist_round(cls, round: RemviesRound) -> int:
        db_data = {
            'id_smap_input': round.id,
            'input': round.input,
            'id_remvies_config': round.id_remvies_config,
            'base_date': round.base_date,
            'cpu_date': round.cpu_date,
        }
        return cls.insert(db_data)
