from datetime import date

from chuva_vazao_utils.exceptions import InflowNotFound
from chuva_vazao_utils.calculator.dao import fetch_productivity
from chuva_vazao_utils.calendar.interval_type import IntervalType
from chuva_vazao_utils.entities.inflow.inflow_type import InflowTypeMenu
from chuva_vazao_utils.calculator.inflow_calculator import InflowCalculator
from chuva_vazao_utils.calculator.expression_calculator import ExpressionCalculator
from chuva_vazao_utils.calculator.expression_parser.ena_ree_expression_parser import EnaReeExpressionParser


class EnaCalculator(ExpressionCalculator):

    def __init__(self, id_power_plant: int, inflows: list, interval_type=IntervalType.DAILY):
        self._inflow_calculator = InflowCalculator(inflows, interval_type)
        self._ena_ree_parser = EnaReeExpressionParser(interval_type)
        self._productivity = fetch_productivity()
        self._id_power_plant = id_power_plant
        self._inflows = inflows

    @property
    def inflows(self):
        return self._inflows

    @inflows.setter
    def inflow(self, inflows):
        self._inflows = inflows

    def eval(self, calculations: dict, inflow_date: date, id_type=None) -> float:
        if 'calculo_vazao' in calculations:
            inflow_value = self._get_inflow_value(calculations, inflow_date, id_type)
            plant_productivity = self._get_productivity()

            if plant_productivity is not None:
                return float(inflow_value) * float(plant_productivity)

        if 'calculo_ena_ree' in calculations:
            self._ena_ree_parser.calculations = calculations
            self._inflow_calculator.inflow_date = inflow_date

            for calculation in calculations['calculo_ena_ree']:
                is_to_calculate = True
                condition = calculation.get('condicao')
                expression = calculation.get('expressao')

                if condition is not None:
                    expression = self._ena_ree_parser.parse(condition)
                    is_to_calculate = self._inflow_calculator.eval_inflow(expression)

                if is_to_calculate:
                    expression = self._ena_ree_parser.parse(expression)

                    return self._inflow_calculator.eval_inflow(expression)

    def _get_inflow_value(self, calculations: dict, inflow_date: date, id_type: int) -> float:
        calculated = self._inflow_calculator.eval(calculations, inflow_date, id_type)
        existing = self._filter_inflow(inflow_date, id_type)

        if calculated is not None:
            inflow_value = calculated

            if existing is not None:
                existing.update({'value': inflow_value})
            else:
                self._inflows.append({
                    'id_power_plant': self._id_power_plant,
                    'inflow_date': inflow_date,
                    'value': inflow_value,
                    'id_type_inflow': id_type or InflowTypeMenu.CALCULADO.value,
                })
        elif existing is not None:
            inflow_value = existing['value']

        else:
            raise InflowNotFound

        return inflow_value

    def _get_productivity(self) -> float:
        def filter_productivity(x):
            return x['id_power_plant'] == self._id_power_plant

        productivity = next(filter(filter_productivity, self._productivity), None)
        if productivity is not None:
            return productivity['valor']

    def _filter_inflow(self, inflow_date: date, id_type: int) -> dict:
        id_power_plant = self._id_power_plant

        def filter_inflow(x):
            is_correct_type = (
                isinstance(x['id_power_plant'], int) or isinstance(x['inflow_date'], date)
            )
            if is_correct_type:
                plant_condition = x['id_power_plant'] == id_power_plant
                date_condition = x['inflow_date'] == inflow_date
                type_condition = not id_type or id_type == x['id_type_inflow']

                return plant_condition and date_condition and type_condition

            msg = 'id_power_plant must be int and inflow_date must be date'
            raise TypeError(msg)

        inflow = next(filter(filter_inflow, self._inflows), None)
        if inflow is not None and 'value' in inflow:
            return inflow
