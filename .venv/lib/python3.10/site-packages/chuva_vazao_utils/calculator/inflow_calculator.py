from datetime import date, timedelta

from chuva_vazao_utils.dao import fetch_power_plants
from chuva_vazao_utils.exceptions import PowerPlantNotFound
from chuva_vazao_utils.calendar.interval_type import IntervalType
from chuva_vazao_utils.calculator.expression_calculator import ExpressionCalculator
from chuva_vazao_utils.calculator.expression_parser.inflow_expression_parser import InflowExpressionParser


class InflowCalculator(ExpressionCalculator):

    def __init__(self, inflows: list, interval_type=IntervalType.DAILY):
        self._parser = InflowExpressionParser(interval_type)
        self._power_plants = fetch_power_plants()
        self._inflows = inflows
        self._id_type = None
        self._inflow_date = None

    @property
    def id_type(self):
        return self._id_type

    @id_type.setter
    def id_type(self, id_type):
        self._id_type = id_type

    @property
    def inflow_date(self):
        return self._inflow_date

    @inflow_date.setter
    def inflow_date(self, inflow_date):
        self._inflow_date = inflow_date

    def eval(self, calculations: dict, inflow_date: date, id_type=None) -> float:
        self._parser.calculations = calculations
        self._parser.reference_date = inflow_date
        self.id_type = id_type
        self.inflow_date = inflow_date

        for calculation in calculations['calculo_vazao']:
            is_to_calculate = True
            condition = calculation.get('condicao')
            expression = calculation.get('expressao')

            if condition is not None:
                condition = self._parser.parse(condition)
                is_to_calculate = self.eval_inflow(condition)

            if is_to_calculate:
                expression = self._parser.parse(expression)
                return self.eval_inflow(expression)

    def eval_inflow(self, expression):
        return eval(expression, {
            'vazao': self.vazao
        })

    def vazao(self, posto_rdh: str, dias=0) -> float:
        inflow_date = self._inflow_date + timedelta(days=dias)
        id_type = self._id_type

        power_plant = self._get_power_plant(posto_rdh)
        id_power_plant = power_plant['id_power_plant']

        def filter_inflow(x):
            plant_condition = x['id_power_plant'] == id_power_plant
            date_condition = x['inflow_date'] == inflow_date
            type_condition = not id_type or id_type == x['id_type_inflow']

            return plant_condition and date_condition and type_condition

        inflow = next(filter(filter_inflow, self._inflows), None)
        if inflow is not None and 'value' in inflow:
            return float(inflow['value'])
        return 0

    def _get_power_plant(self, posto_rdh):
        if isinstance(posto_rdh, str):
            power_plant = next(filter(
                lambda x: x['posto_rdh'] == posto_rdh,
                self._power_plants
            ), None)
            if power_plant is not None:
                return power_plant

            msg = f'Power plant not found (posto_rdh: {posto_rdh})'
            raise PowerPlantNotFound(msg)
        raise TypeError('posto_rdh must be string')
