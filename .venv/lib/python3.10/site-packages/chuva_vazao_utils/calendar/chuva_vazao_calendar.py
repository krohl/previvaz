import re
import calendar
from enum import Enum
from typing import List, Tuple
from datetime import date, datetime, timedelta
from functools import lru_cache

from dateutil.relativedelta import relativedelta

from chuva_vazao_utils.calendar import dao
from chuva_vazao_utils.exceptions import InvalidDate, DateTypeError, InvalidWeekNumber


class CalendarType(Enum):
    SIMPLE = 0
    SIMPLE_COMPATIBLE = 0.1
    # Simple calendar, with fake dates, but compatible with CALENDAR_ONS: using externally, one would not feel any difference
    CALENDAR_ONS = 1
    CALENDAR_BBCE = 2

    @staticmethod
    def to_list():
        return list(CalendarType)


class DateType(Enum):
    WORKDAY = 1
    WEEKEND = 2
    HOLIDAY = 3


class ChuvaVazaoCalendar:

    def __init__(self, year: int, calendar_type: CalendarType, ignore_cache: bool = False):
        self._calendar_type = calendar_type
        self._year = year
        self._round_weekday = calendar.THURSDAY
        self._cal = calendar.Calendar(firstweekday=5)
        self._weeks = self._get_weeks(year)
        if(ignore_cache):
            self.clear_cache()
        self._dates = self.fetch_dates()

    @property
    def dates(self):
        return self._dates

    @property
    def round_weekday(self):
        return self._round_weekday

    @round_weekday.setter
    def round_weekday(self, round_weekday: int):
        self._round_weekday = round_weekday

    @classmethod
    def clear_cache(cls):
        dao.fetch_calendar.__wrapped__.cache_clear()

    def fetch_dates(self) -> List[dict]:
        if self._calendar_type == CalendarType.SIMPLE:
            return self._create_simple_calendar()
        elif self._calendar_type == CalendarType.SIMPLE_COMPATIBLE:
            return self._create_simple_compatible_calendar()
        else:
            return dao.fetch_calendar(self._year, self._calendar_type.value)

    def _create_simple_calendar(self):
        sdate = date(self._year - 1, 1, 1)
        edate = date(self._year + 1, 12, 31)
        delta = edate - sdate

        return [
            sdate + timedelta(days=i)
            for i in range(delta.days + 1)
        ]

    def _create_simple_compatible_calendar(self):
        simple_calendar = self._create_simple_calendar()

        return [{'date': simple_date,
                 'id_date_type': DateType.WEEKEND.value if simple_date.weekday() in [calendar.SATURDAY, calendar.SUNDAY] else DateType.WORKDAY.value,
                 'name': 'fim de semana' if simple_date.weekday() in [calendar.SATURDAY, calendar.SUNDAY] else 'dia Ãºtil'}
                for simple_date in simple_calendar]

    def get_dates_between(self, start_date: date, end_date: date) -> List[dict]:
        """Get date range between two dates

        Args:
            start_date (date): start of date range
            end_date (date): end of date range

        Returns:
            List[dict]: date range
        """
        def filter_dates(x):
            if isinstance(x, date):
                return x <= end_date and x >= start_date

            if isinstance(x, dict):
                return x['date'] <= end_date and x['date'] >= start_date

        return list(filter(filter_dates, self.dates))

    def filter_by_date_type(self, date_type: DateType) -> List[dict]:
        """Filters dates by type

        Args:
            date_type (DateType): date type

        Returns:
            List[dict]: date list
        """
        if self._calendar_type == CalendarType.SIMPLE:
            raise DateTypeError('Simple Calendar has no date type')

        return list(filter(
            lambda x: x['id_date_type'] == date_type.value,
            self.dates
        ))

    @lru_cache(maxsize=64)
    def get_rv(self, reference_date: date) -> Tuple[int, date]:
        """Get rv and operative week date from reference date

        Args:
            reference_date (date): reference date

        Returns:
            Tuple[int, date]: rv and operative week date
        """
        rv = 0
        for i, week in enumerate(self._weeks):
            previous_week = self._weeks[i - 1]

            if week.month != previous_week.month:
                rv = 0
            else:
                rv += 1
            if reference_date > previous_week and reference_date <= week:
                return rv, week

    def get_n_week(self, reference_date: date) -> int:
        """Get week number from reference date

        Args:
            reference_date (date): reference date

        Returns:
            int: n week
        """
        year_weeks = [w for w in self._weeks if w.year == reference_date.year]
        try:
            return year_weeks.index(reference_date) + 1
        except ValueError as e:
            raise InvalidDate(f'{reference_date} is not a valid date') from e

    def get_dates_from_n_week(self, n_week: int, year: int) -> Tuple[date]:
        """Get the beginning and end of the week from the week number

        Args:
            n_week (int): n week
            year (int): year

        Returns:
            Tuple[date]: beginning and end of the week
        """
        try:
            year_weeks = [w for w in self._weeks if w.year == year]
            end_date = year_weeks[n_week - 1]
            start_date = end_date - timedelta(days=6)
            return start_date, end_date
        except IndexError as e:
            raise InvalidWeekNumber(f'{n_week} is not a valid week') from e

    def next_week(self, reference_date: date) -> date:
        """Get next operative week

        Args:
            reference_date (date): Reference date to be found the next week

        Returns:
            date: Next operative week
        """
        return next(filter(lambda x: reference_date < x, self._weeks))

    @staticmethod
    def opweek_to_rv(week: str) -> int:
        """Parse operative week string to rv number
        e.g.: 2021041 -> 0

        Args:
            week (str): operative week

        Returns:
            int: rv number
        """
        n_operative_week = re.findall(r'[0-9]\d{6}', week)[0][-1]
        return int(n_operative_week) - 1

    def opweek_to_date(self, week: str) -> date:
        """Parse operative week string to date
        e.g.: 2021041 -> date(2021, 4, 2)

        Args:
            week (str): operative week

        Returns:
            date: operative week date
        """
        operative_week = re.findall(r'[0-9]\d{6}', week)[0][:6]
        rv = self.opweek_to_rv(week)
        year_month = datetime.strptime(operative_week, '%Y%m')
        month_rvs = list(filter(lambda x: x.year == year_month.year and x.month == year_month.month, self._weeks))

        return month_rvs[rv]

    @staticmethod
    @lru_cache(maxsize=64)
    def get_next_weekday(data: date, weekday: int) -> date:
        data += timedelta(days=1)
        while data.weekday() != weekday:
            data += timedelta(days=1)
        return data

    @staticmethod
    @lru_cache(maxsize=64)
    def get_previous_weekday(data: date, weekday: int) -> date:
        data -= timedelta(days=1)
        while data.weekday() != weekday:
            data -= timedelta(days=1)
        return data

    def is_round_date(self, reference_date: date) -> bool:
        """Check if reference date is round date

        Args:
            reference_date (date): reference date

        Returns:
            bool: if reference date is round date
        """
        return reference_date.weekday() == self._round_weekday

    @lru_cache(maxsize=64)
    def get_previous_round_date(self, reference_date: date) -> date:
        previous_date = self.get_previous_weekday(reference_date, self._round_weekday)
        week_date = self.get_previous_weekday(previous_date, self._round_weekday)
        return self.get_next_round_date(week_date)

    @lru_cache(maxsize=64)
    def get_next_round_date(self, reference_date: date) -> date:
        """Get next round date, consider holidays

        Args:
            reference_date (date): [description]

        Returns:
            date: [description]
        """
        _, rv_date = self.get_rv(reference_date)
        start_rv = rv_date - timedelta(days=6)

        start_nxt = rv_date + timedelta(days=1)
        _, nxt_rv_date = self.get_rv(start_nxt)

        start_dt_week = start_rv
        end_dt_week = rv_date

        if reference_date.weekday() in [calendar.THURSDAY, calendar.FRIDAY]:
            start_dt_week = start_nxt
            end_dt_week = nxt_rv_date

        week_dates = self.get_dates_between(start_dt_week, end_dt_week)
        holidays = self.filter_by_date_type(DateType.HOLIDAY)

        weekdays_holidays = [
            dt['date'].weekday() for dt in week_dates
            if dt in holidays and dt['date'].weekday() in [
                calendar.WEDNESDAY, calendar.THURSDAY, calendar.FRIDAY
            ]
        ]
        holidays_wednesday = [
            w for w in weekdays_holidays
            if w == calendar.WEDNESDAY
        ]
        n_holidays = len(weekdays_holidays)

        if n_holidays == 0:
            dt_round = self.get_next_weekday(start_dt_week, calendar.THURSDAY)

        elif n_holidays == 3:
            # Holidays WEDNESDAY and THURSDAY and FRIDAY
            dt_round = self.get_next_weekday(start_dt_week, calendar.MONDAY)

        elif n_holidays == 2:
            # Holidays THURSDAY and FRIDAY or WEDNESDAY and THURSDAY or WEDNESDAY and FRIDAY
            dt_round = self.get_next_weekday(start_dt_week, calendar.TUESDAY)

        elif n_holidays == 1 and not any(holidays_wednesday):
            # Holidays THURSDAY or FRIDAY
            dt_round = self.get_next_weekday(start_dt_week, calendar.WEDNESDAY)
        else:
            # Holidays WEDNESDAY
            dt_round = self.get_next_weekday(start_dt_week, calendar.THURSDAY)

        if reference_date >= dt_round:
            return self.get_next_round_date(rv_date)

        return dt_round

    @lru_cache(maxsize=64)
    def _get_weeks(self, year: int) -> List[date]:
        weeks = []
        month = 1
        previous_year = year - 1
        next_year = year + 1
        weekdate = date(previous_year, month, 1)

        while next_year >= weekdate.year:
            monthdates = self._cal.itermonthdates(weekdate.year, month)
            weeks.extend([
                month_date for month_date in monthdates
                if month_date.weekday() == calendar.FRIDAY
            ])
            weeks = list(set(weeks))
            weekdate = weekdate + relativedelta(months=1)
            month = weekdate.month

        weeks.sort()
        return weeks

    def find_deck_date(self, ref_date: date, start_forecast_week: date, end_forecast_week: date) -> date:
        not_found_deck_date = True
        deck_date = ref_date
        aux_round_date = ref_date

        while not_found_deck_date:
            if deck_date >= start_forecast_week and deck_date <= end_forecast_week:
                not_found_deck_date = False
            else:
                aux_round_date = deck_date
                deck_date = self.get_next_round_date(deck_date)

        return aux_round_date

    @staticmethod
    def get_month_abbr(n_month) -> str:
        months = {
            'jan': 1, 'fev': 2, 'mar': 3, 'abr': 4, 'mai': 5, 'jun': 6,
            'jul': 7, 'ago': 8, 'set': 9, 'out': 10, 'nov': 11, 'dez': 12
        }
        months_txt = list(months.keys())
        n_months = list(months.values())
        return months_txt[n_months.index(n_month)]
