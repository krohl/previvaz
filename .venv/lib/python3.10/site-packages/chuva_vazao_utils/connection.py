import warnings
import pymysql

from abc import ABC
from enum import Enum
from pymysql.connections import Connection
from pymysql.cursors import Cursor

from chuva_vazao_utils.aws.secrets_manager import get_secret_value
from chuva_vazao_utils.exceptions import InvalidDatabase


class Database(ABC):
    # Se projetos externos chamam diretamente essa classe Database, precisaríamos colocar o endereço do secret do river aqui, para não haver impacto algum.
    # Ou documentamos e nos ligamos que, da nova versão em diante, é preciso trocar 'Database' por 'RiverDatabase'
    _SECRET_KEY: str = ''
    _DB_NAME: str = ''
    _connection = None

    @classmethod
    def get_connection(cls) -> Connection:
        if cls._connection is None or not cls._connection.open:
            secret = get_secret_value(cls._SECRET_KEY)
            host = secret["host"]
            user = secret["username"]
            password = secret["password"]
            database = cls._DB_NAME
            port = secret["port"]

            cls._connection = pymysql.connect(
                host=host,
                user=user,
                password=password,
                db=database,
                port=int(port),
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor
            )

        return cls._connection

    @classmethod
    def execute(cls, sql, params=(), auto_commit: bool = True) -> Cursor:
        connection = cls.get_connection()

        try:
            with connection.cursor() as cursor:
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore", pymysql.Warning)
                    cursor.execute(sql, params)
                    if auto_commit:
                        connection.commit()

                return cursor
        except Exception:
            connection.rollback()
            raise

    @classmethod
    def executemany(cls, sql, params=None, auto_commit: bool = True) -> Cursor:
        if params is None:
            params = []
        connection = cls.get_connection()

        try:
            with connection.cursor() as cursor:
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore", pymysql.Warning)
                    cursor.executemany(sql, params)
                    if auto_commit:
                        connection.commit()

                return cursor
        except Exception:
            connection.rollback()
            raise


class RiverDatabase(Database):
    _SECRET_KEY = '/databases/esferadb-river/preco_automatico'
    _DB_NAME = 'river'


class ChuvaVazaoDatabase(Database):
    _SECRET_KEY = '/databases/esferadb-river/preco_automatico'
    _DB_NAME = 'chuva_vazao'


class SisCadDatabase(Database):
    _SECRET_KEY = '/databases/esferadb/escore'
    _DB_NAME = 'SIS_CAD'


class MtorPrdDatabase(Database):
    _SECRET_KEY = '/databases/esferadb/escore'
    _DB_NAME = 'MTOR_PRD'


class SentraDatabase(Database):
    _SECRET_KEY = '/databases/esferadb/escore'
    _DB_NAME = 'SENTRA'


class VarejistaDatabase(Database):
    _SECRET_KEY = '/databases/esferadb/escore'
    _DB_NAME = 'varejista'


class DatabaseMenu(Enum):
    RIVER_DB = 10,
    CHUVA_VAZAO_DB = 20,
    SIS_CAD_DB = 30
    MTOR_PRD = 40
    SENTRA = 50
    VAREJISTA = 60


class DatabaseSelector:
    _DATABASES_MAP = {
        DatabaseMenu.RIVER_DB: RiverDatabase,
        DatabaseMenu.CHUVA_VAZAO_DB: ChuvaVazaoDatabase,
        DatabaseMenu.SIS_CAD_DB: SisCadDatabase,
        DatabaseMenu.MTOR_PRD: MtorPrdDatabase,
        DatabaseMenu.SENTRA: SentraDatabase,
        DatabaseMenu.VAREJISTA: VarejistaDatabase
    }

    @classmethod
    def get_database(cls, database: DatabaseMenu):
        if database in DatabaseSelector._DATABASES_MAP:
            return DatabaseSelector._DATABASES_MAP[database]
        raise InvalidDatabase(f'Invalid DatabaseMenu: {database}')
