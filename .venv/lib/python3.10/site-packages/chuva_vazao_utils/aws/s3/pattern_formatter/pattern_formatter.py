import re
from abc import ABC, abstractmethod
from datetime import date, datetime
from typing import List

from chuva_vazao_utils.utils.logger import logger


class S3PatternFormatter(ABC):
    @classmethod
    @abstractmethod
    def format_pattern(cls, pattern: str, *args, **kwargs) -> str:
        raise NotImplementedError()

    @classmethod
    def _get_format_date_dict(cls, date_to_fmt: date, pattern_with_date_fmt: str) -> dict:
        """Função focada na formatação de patterns utilizados para os modelos PMEDIA. Quando há a formação de uma data,
        ela segue o formato 'nome_da_data_%Y%m%d', sendo o %Y%m%d o formato a ser aplicado.

        Essa função recebe uma data (`date_to_fmt`) e o padrão (`pattern_with_date_fmt`) no formato 'nome_da_data_%Y%m%d'
        Retorna-se um dicionário: {pattern_with_date_fmt: `data_formatada`}, onde `data_formatada` é a `date_to_fmt` aplicado o formato %Y%m%d

        Exemplo: O modelo EC 15 tem o filename_pattern = "ECMWF_ECMWF15.PMEDIA_p{data_date_%d%m%y}a{target_date_%d%m%y}.dat"
                 Para formatar essa string, buscando a previsão de chuva do dia 03/03/2023 para o 04/03/2023, é preciso do dicionário de formatação:
                 {"data_date_%d%m%y": "030323", "target_date_%d%m%y": "040323"}.
                 Neste caso, a presente função seria chamada duas vezes:
                 1- date_to_fmt = 03/03/2023; pattern_with_date_fmt = "data_date_%d%m%y"   retorna: {"data_date_%d%m%y": "030323"}
                 2- date_to_fmt = 04/03/2023; pattern_with_date_fmt = "target_date_%d%m%y" retorna: {"target_date_%d%m%y": "040323"}

        Args:
            date_to_fmt (date): data a ser formatada
            fmt (str): padrão de formatação, no formato 'nome_da_data_%Y%m%d' (ver exemplo acima)

        Returns:
            dict: Dicionário {'pattern_with_date_fmt': "data_formatada"} (ver exemplo acima)
        """
        date_fmt = pattern_with_date_fmt.rsplit('_', 1)[-1]
        return {pattern_with_date_fmt: date_to_fmt.strftime(date_fmt)}

    @classmethod
    def _get_date_from_formated_str_pattern(
        cls, formated_string: str, pattern: str, patterns_priority: List[str], log_errors: bool = False
    ) -> date:
        """Função extrai uma data de uma string (`formated_string`) que segue um padrão de formatação (`pattern`), seguindo a ordem
        de prioridade de `patterns_priority`.

        Exemplo 1:
        - `formated_string`   = mock_p150223a160223.dat
        - `pattern`           = mock_p{round_base_date_%d%m%y}a{target_date_%d%m%y}.dat
        - `patterns_priority` = [{round_base_date_%d%m%y}, {target_date_%d%m%y}]
                              -> retorna date(2023, 2, 15)

        Exemplo 2:
        - `formated_string`   = mock_p150223a160223.dat
        - `pattern`           = mock_p{round_base_date_%d%m%y}a{target_date_%d%m%y}.dat
        - `patterns_priority` = [{anything_%d%m%y}, {target_date_%d%m%y}]
                              -> retorna date(2023, 2, 16)

        Args:
            formated_string (str): string que segue o padrão `pattern`, mas que já foi formatada
            pattern (str): Padrão segundo o qual a data da string será decodificada
            patterns_priority (List[str]): A busca da data se dará na ordem dada por `patterns_priority`
            log_errors (bool, optional): Define se erros de decodificação serão logados. Defaults to False.

        Returns:
            date: _description_
        """
        decoded_pattern_values = cls._get_formated_string_pattern_params(formated_string, pattern)

        for pattern in patterns_priority:
            if pattern in decoded_pattern_values:
                value_extracted_from_str = decoded_pattern_values[pattern]
                date_pattern = pattern.rsplit('_', 1)[-1]

                try:
                    return cls._create_date_from_pattern(pattern, value_extracted_from_str, date_pattern)
                except ValueError:
                    if log_errors:
                        logger.error(
                            f'Padrão não decodificado para a string "{formated_string}". Encontrado "{value_extracted_from_str}" no lugar de '
                            f'"{pattern}" e a conversão para data não foi possível.'
                        )
        if log_errors:
            logger.error(f'String "{formated_string}" não decodificado a partir de padrão "{pattern}"')

    @classmethod
    def _create_date_from_pattern(cls, pattern: str, value_extracted_from_str: str, date_pattern: str) -> date:
        return datetime.strptime(value_extracted_from_str, date_pattern).date()

    @classmethod
    def _get_formated_string_pattern_params(cls, formated_string: str, pattern: str, log_errors=False) -> dict:
        """Returns a dict with the formatted values of a string, given a pattern.

        Example:
        - formated_string: 'mock_1234_5678'
        - pattern:         'mock_{num1}_{num2}'
                            -> returns {'num1': '1234', 'num2': '5678'}
        """
        regex = re.sub(r'{(.+?)}', r'(?P<_\1>.+)', pattern)
        keys = re.findall(r'{(.+?)}', pattern)

        for i, k in enumerate(keys):
            regex = regex.replace(k, f'key_{i}')

        searched = re.search(regex, formated_string)
        if not searched:
            if log_errors:
                logger.error(f'Não foi possível decodificar string "{formated_string}" do padrão "{pattern}"')
            return {}
        values = list(re.search(regex, formated_string).groups())
        _dict = dict(zip(keys, values))
        return _dict
